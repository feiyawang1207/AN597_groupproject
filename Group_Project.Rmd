---
title: "Group_Project"
author: "Feiya Wang"
date: "11/11/2019"
output: html_document
---
***
## Group Project--Species Distribution Model

***
It is a Group projetc worked by Majo, Frank and Feiya

## Introduction: short paragraph and an image

>Packages to be used: install.packages(c(’raster’, ’rgdal’, ’dismo’, ’rJava’)) 

# Data preparation - due Monday 18th

# Species occurrence data

>1.Upload files

If You have a files, than you can upload it like we did in previous class, using curl package. 

For example:

```{r}
library (curl)
#install package curl before this step to load a file from server.

f <- curl("https://github.com/feiyawang1207/AN597_groupproject/blob/master/S_angustifolium.xlsx")
#load the file in varibale f
d <- read.csv(f, header = TRUE, sep = ",", stringsAsFactors = FALSE)
# read file in d as a dataframe.

head(d)
```


If you do not have any species distribution data you can get started by downloading data from the Global Biodiversity Inventory Facility (GBIF).Importing data from a database, we use a function called gbif() to download the files from this database. 

```{r}
library(dismo)
#library(DT)

acaule <- gbif("solanum", "acaule*", geo=FALSE)
#load the saved S. acaule data from data base

datatable(head(acaule))
#
```

If you want to check how many rows and colums the data frame you have, we use dim() to show the dimension of the dataset.
```{r}
colrow<-dim(acaule)
# use dim() to get dimension of our dataset

colrow[1]
#show row numbers

y<-colrow[2]
#show column number
```

In order to drawing a map, we need to find the location by Longitude and latitude from dataset. 

Subetting the data that have longitude and latitude, ingore all the NA values. We use is.na() to test the data that have both longitude and latitude data and make them into a data frame.
```{r}
acgeo <- subset(acaule, !is.na(lon) & !is.na(lat))
#use subset() to seperate those data

#datatable(head(acgeo))
#showing the example data see that have longtitude and lagititude data

dim(acgeo)
#showing the rows and columns for data frame
```
show some values
# ???
I don't understand this function.
```{r}
acgeo[1:4, c(1:5,7:10)] #removing locality
```

> 2.Importing data: Species occurrence data, plot map

In order to do tha, we need package maptools. 

First, we need to draw a empty map. a variable called wrld_simpl will show a empty world-wide map
```{r}
library(maptools)

data(wrld_simpl)
x<-plot(wrld_simpl, xlim=c(-80,70), ylim=c(-80,30), axes=TRUE)
# empty map
```


Then we need to put data
```{r}
library(maptools)

data(wrld_simpl)
plot(wrld_simpl, xlim=c(-80,70), ylim=c(-80,30), axes=TRUE, col="light yellow")
# restore the box around the map
box()
# add the points
points(acgeo$lon, acgeo$lat, col='orange', pch=20, cex=0.75)
# plot points again to add a border, for better visibility
points(acgeo$lon, acgeo$lat, col='red', cex=0.75)
```

```{r}
 r <- raster(system.file("external/test.grd", package="raster"))

```

>Data cleaning-majo

```{r}
acaule[c(303,885),1:10]
```


```{r}
lonzero = subset(acgeo, lon==0)
lonzero[, 1:13]
```


>Duplicate records: The next function helps to remove duplicates.

```{r}
#which records are duplicates (only for the first 10 columns)?
dups <- duplicated(lonzero[, 1:10])
#remove duplicates
lonzero  <-  lonzero[dups, ]
lonzero[,1:13]
```
>Another approach might be to detect duplicates for the same species and some coordinates in the data, even if the records were from collections by different people or in different years (in our case, using species is redundant as we have data for only one species).

```{r}
# differentiating by (sub) species
# dups2 <- duplicated(acgeo[, c('species', 'lon', 'lat')])
# ignoring (sub) species and other naming variation
dups2 <- duplicated(acgeo[, c('lon', 'lat')])
# number of duplicates
sum(dups2)
## [1] 483
# keep the records that are _not_ duplicated
acg <- acgeo[!dups2, ]
```

>Let’s repatriate the records near Pakistan to Argentina, and remove the records in Brazil, Antarctica, and with longitude=0

```{r}
i <- acg$lon > 0 & acg$lat > 0
acg$lon[i] <- -1 * acg$lon[i]
acg$lat[i] <- -1 * acg$lat[i]
acg <- acg[acg$lon < -50 & acg$lat > -50, ]
```

>Cross-checking: 

```{r}
library(sp)
coordinates(acg) <- ~lon+lat
crs(acg) <- crs(wrld_simpl)
class(acg)
## [1] "SpatialPointsDataFrame"
## attr(,"package")
## [1] "sp"
```

```{r}
class(wrld_simpl)
## [1] "SpatialPolygonsDataFrame"
## attr(,"package")
## [1] "sp"
ovr <- over(acg, wrld_simpl)
```

```{r}
head(ovr)
cntr <- ovr$NAME
```

```{r}
i <- which(is.na(cntr))
i
## integer(0)
j <- which(cntr != acg$country)
# for the mismatches, bind the country names of the polygons and points
cbind(cntr, acg$country)[j,]
##      cntr
## [1,] "27"  "Argentina"
## [2,] "172" "Bolivia"
## [3,] "172" "Bolivia"
## [4,] "172" "Bolivia"
```

```{r}
plot(acg)
plot(wrld_simpl, add=T, border='blue', lwd=2)
points(acg[j, ], col='red', pch=20, cex=2)
```

>Absence and background points: 

Some of the early species distribution model algorithms, such as Bioclim and Domain only use ’presence’ data in the modeling process. Other methods also use ’absence’ data or ’background’ data.

Therefore, if you want to have a non-NA-value data frame for your method, Here is the thing you could do.

First, there is a common methods to delete all NA values from a data frame. We can use na.omit() function to delete the rows that contains the NA data.
 For example, you only need longtitude and latitude values to draw your map, then, you can take those two columns into a data frame. 

```{r}
long<-acaule$lon
#extract column of longtitude
lati<-acaule$lat
#extract column of latitude
d<-cbind(long,lati)
#combine into a data frame
colnames(d)<-c("longitude","latitude")
#name data frame

dim(d)[1]
#rows number of uncleaning data frame

d[27,]
#a NA rows in this data frame
```

Then, you can use na.omit() to delete all NA value from this data frame. 
```{r}
clean_d <-na.omit(d)
#save teh cleaing data frame

dim(clean_d)[1]
#rows number of cleaning data frame

clean_d[27,]
#NA have been removed from the previous row.

```

The dismo package also have some function to delete NA data from the data frame.
For example, raster()
 


# Environmental data Due 25th

>Raster data

A raster consists of a matrix of cells (or pixels) organized into rows and columns (or a grid) where each contains a value representing information. Raster format represents real-world phenomena, data might be discrete or continuous. 
Discrete data: also are called thematic, categorical or discontinuous data. A discrete object has known and definable boundaries. 
In species distribution modeling, predictor variables are typically organized as raster (grid) type files. Each predictor should be a ‘raster’ representing a variable of interest. Variables can include climatic, soil, terrain, vegetation, land use, and other variables.
These data are typically stored in files in some kind of GIS format. Almost all relevant formats can be used (including ESRI grid, geoTiff, netCDF, IDRISI).
For any particular study the layers should all have the same spatial extent, resolution, origin, and projection. 
The set of predictor variables (rasters) can be used to make a RasterStack, which is a collection of `RasterLayer’ objects 

A RasterLayer object represents single-layer (variable) raster data. A RasterLayer object always stores a number of fundamental parameters that describe it. These include the number of columns and rows, the spatial extent, and the Coordinate Reference System. In addition, a RasterLayer can store information about the file in which the raster cell values are stored (if there is such a file). A RasterLayer can also hold the raster cell values in memory.

Using the dismo package we are going to create a rasterStack from the list of files are intalled in the package. 
Fist, we need to get the folder with our files.....

```{r}
path <- file.path(system.file(package="dismo"), 'ex')
```



```{r}
library(dismo)
files <- list.files(path, pattern='grd$', full.names=TRUE )
files
```
```{r}
predictors <- stack(files)
predictors
```
```{r}
names(predictors)
```


```{r}
plot(predictors)
```


```{r}
library(maptools)
data(wrld_simpl)
file <- paste(system.file(package="dismo"), "/ex/bradypus.csv", sep="")
bradypus <- read.table(file,  header=TRUE,  sep=',')
# we do not need the first column
bradypus  <- bradypus[,-1]
```



```{r}
# first layer of the RasterStack
plot(predictors, 1)
# note the "add=TRUE" argument with plot
plot(wrld_simpl, add=TRUE)
# with the points function, "add" is implicit
points(bradypus, col='blue')
```

>Extracting values from rasters



# Model fitting, prediction, and evaluation
>Model fitting

>Model prediction

>Model evaluation

>Types of models

# Generalized Linear Models: example









```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

